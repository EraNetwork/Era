// Copyright (c) 2009-2018 The Era developers
// Distributed under the MIT/X11 software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <boost/assign/list_of.hpp> // for 'map_list_of()'
#include <boost/foreach.hpp>

#include "checkpoints.h"

#include "main.h"
#include "txdb.h"
#include "uint256.h"


static const int nCheckpointSpan = 500;

namespace Checkpoints {
typedef std::map<int, uint256> MapCheckpoints;

//
// What makes a good checkpoint block?
// + Is surrounded by blocks with reasonable timestamps
//   (no blocks before with a timestamp after, none after with
//    timestamp before)
// + Contains no strange transactions
//
static MapCheckpoints mapCheckpoints =
    boost::assign::map_list_of(0, uint256("0x0000aab7dff29b0749519a7886b8a8d3f2806eb5dd861f9a0dbb7441f9a97f6a"))(4, uint256("0x000059e51262fbdb6b5b636fb841a01f0f13fff549b801265fa751141b8a18ca"))(5, uint256("0x0000b023d186b6986b58373680cfc9e4dd13e70c51a2964688f3f1b4e58b8d8d"));

// TestNet has no checkpoints
static MapCheckpoints mapCheckpointsTestnet;

bool CheckHardened(int nHeight, const uint256& hash)
{
    MapCheckpoints& checkpoints = (TestNet() ? mapCheckpointsTestnet : mapCheckpoints);

    MapCheckpoints::const_iterator i = checkpoints.find(nHeight);
    if (i == checkpoints.end()) return true;
    return hash == i->second;
}

int GetTotalBlocksEstimate()
{
    MapCheckpoints& checkpoints = (TestNet() ? mapCheckpointsTestnet : mapCheckpoints);

    if (checkpoints.empty())
        return 0;
    return checkpoints.rbegin()->first;
}

CBlockIndex* GetLastCheckpoint(const std::map<uint256, CBlockIndex*>& mapBlockIndex)
{
    MapCheckpoints& checkpoints = (TestNet() ? mapCheckpointsTestnet : mapCheckpoints);

    BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, checkpoints)
    {
        const uint256& hash = i.second;
        std::map<uint256, CBlockIndex*>::const_iterator t = mapBlockIndex.find(hash);
        if (t != mapBlockIndex.end())
            return t->second;
    }
    return NULL;
}

// Automatically select a suitable sync-checkpoint
const CBlockIndex* AutoSelectSyncCheckpoint()
{
    const CBlockIndex* pindex = pindexBest;
    // Search backward for a block within max span and maturity window
    while (pindex->pprev && pindex->nHeight + nCheckpointSpan > pindexBest->nHeight)
        pindex = pindex->pprev;
    return pindex;
}

// Check against synchronized checkpoint
bool CheckSync(int nHeight)
{
    const CBlockIndex* pindexSync = AutoSelectSyncCheckpoint();

    if (nHeight <= pindexSync->nHeight)
        return false;
    return true;
}
} // namespace Checkpoints
